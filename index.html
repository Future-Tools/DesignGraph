<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Interactive UML Graph</title>
  <style>
    body { margin: 0; background: #f8f8f8; }
    #3d-graph { width: 100vw; height: 100vh; display: block; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
  <script src="js/graph-data.js"></script>
</head>
<body>
  <div id="3d-graph"></div>
  <div id="info-box" style="
    position:fixed;
    top:32px;
    right:32px;
    min-width:240px;
    max-width:340px;
    background:#fff;
    color:#222;
    padding:20px 28px;
    border-radius:12px;
    box-shadow:0 4px 24px #0002;
    font-size:18px;
    z-index:10;
    display:none;
    font-family: 'Segoe UI', 'Arial', sans-serif;
    border: 1px solid #e0e0e0;
    letter-spacing: 0.01em;
    line-height: 1.6;
  "></div>

  <script>
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;
    let selectedNode = null;
    const neighborNodes = new Set();

    const infoBox = document.getElementById('info-box');

    const Graph = ForceGraph3D()
      (document.getElementById('3d-graph'))
      .graphData(gData)
      .backgroundColor("#fff")
      .nodeAutoColorBy(node => node.group === 'main' ? node.id : 'attr')
      .nodeLabel(node => node.label || node.id)
      .linkWidth(link => highlightLinks.has(link) ? 1.5 : 0.5)
      .linkColor(link => highlightLinks.has(link) ? '#0f0' : '#000')
      .nodeColor(node =>
        node.id === 'KPI'
          ? '#d32f2f' // always red for KPI node
          : selectedNode && node.id === selectedNode.id
            ? '#7ecb7e' // light green for selected node
            : neighborNodes.has(node)
              ? '#006400' // dark green for neighbors
              : (node.group === 'main'
                  ? '#222' // dark for main nodes
                  : '#bbb' // grey for attribute nodes
                )
      )
      .onNodeClick(node => {
        highlightNodes.clear();
        highlightLinks.clear();
        neighborNodes.clear();

        // Find connected nodes and their relation types
        const connected = [];
        Graph.graphData().links.forEach(link => {
          const src = typeof link.source === 'object' ? link.source.id : link.source;
          const tgt = typeof link.target === 'object' ? link.target.id : link.target;
          let neighborId, direction;
          if (src === node.id) {
            neighborId = tgt;
            direction = 'out';
          } else if (tgt === node.id) {
            neighborId = src;
            direction = 'in';
          } else {
            return;
          }
          const neighbor = Graph.graphData().nodes.find(n => n.id === neighborId);
          if (!neighbor) return;
          neighborNodes.add(neighbor);

          if (link.type === 'attribute') {
            // Show only the attribute name, not the full id
            const attrName = neighbor.label || (neighbor.id.split('.').pop());
            connected.push(`(Attribute, ${attrName})`);
          } else {
            // Show just the object name (label or id)
            connected.push(neighbor.label || neighbor.id);
          }
          highlightLinks.add(link);
        });

        selectedNode = node;

        // Refresh
        Graph.nodeColor(Graph.nodeColor());
        Graph.linkWidth(Graph.linkWidth());
        Graph.linkColor(Graph.linkColor());

        // Show info box
        infoBox.style.display = 'block';
        infoBox.innerHTML = `
          <div style="font-weight:600;font-size:20px;margin-bottom:8px;">${node.label || node.id}</div>
          <div style="font-weight:400;font-size:16px;margin-bottom:6px;color:#666;">Connected nodes:</div>
          <div style="font-size:16px;">
            ${connected.map(c => `<div style="margin-bottom:2px;">${c}</div>`).join('')}
          </div>
        `;

        // Move camera to focus on node
        const distance = 180;
        const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
        Graph.cameraPosition(
          { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
          node,
          3000
        );
      });

    function capitalize(str) {
      return str ? str.charAt(0).toUpperCase() + str.slice(1) : '';
    }

    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        infoBox.style.display = 'none';
        highlightLinks.clear();
        highlightNodes.clear();
        neighborNodes.clear();
        selectedNode = null;
        Graph.nodeColor(Graph.nodeColor());
        Graph.linkWidth(Graph.linkWidth());
        Graph.linkColor(Graph.linkColor());
      }
    });
  </script>
</body>
</html>
